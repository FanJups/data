// Copyright (c) 2022,2023 Contributors to the Eclipse Foundation
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

== Repository

In Domain-Driven Design (DDD) the repository pattern encapsulates the logic required to access data sources. The repository pattern consolidates data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.

image::01-repository.png[alt=repository structure, width=70%, height=70%]

This pattern focuses on the closest proximity of entities and hides where the data comes from.

The Repository pattern is a well-documented way of working with a data source. In the book Patterns of Enterprise Application Architecture, Martin Fowler describes a repository as follows:

> A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory. Client objects declaratively build queries and send them to the repositories for answers. Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer. Repositories also support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.

It also becomes very famous in Domain-Driven Design: Tackling Complexity in the Heart of Software by Eric Evans.

=== Repositories on Jakarta Data

A repository abstraction aims to significantly reduce the boilerplate code required to implement data access layers for various persistence stores.

In Jakarta Data, a repository is an interface that is annotated with the `@Repository` annotation.

The Jakarta Data specification defines several built-in interfaces from which repositories can inherit as a convenient way to include a variety of pre-defined methods for operations that are commonly used and to declare the entity type to use for methods from which the entity type cannot otherwise be inferred.

The parent interface at the root of the hierarchy of built-in interfaces is `DataRepository`. All of the built-in interfaces are extensible. A repository might extend one or more of the built-in interfaces or none of them. Method signatures that are copied from the built-in interfaces to a repository must have the same behavior as defined on the built-in interface.

[ditaa]
....
                          +----------------+
                          | DataRepository |
                          +----------------+
                                  ^
                                  |
                                  |
                          +----------------+
                          | CrudRepository | 
                          +----------------+ 
                                  ^
                                  |
                                  |
                        +--------------------+
                        | PageableRepository |
                        +--------------------+
....

* Interface with generic CRUD operations on a repository for a specific type. This one we can see more often on several Java implementations.
* Interface with generic CRUD operations using the pagination feature.

From the Java developer perspective, create an interface that is annotated with the `@Repository` annotation and optionally extends one of the built-in repository interfaces.

So, given a `Product` entity where the ID is a `long` type, the repository would be:

[source,java]
----
@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {

}
----


There is no nomenclature restriction to make mandatory the `Repository` suffix. Such as, you might represent the repository of the Car's entity as a `Garage` instead of `CarRepository`.

[source,java]
----
@Repository
public interface Garage extends CrudRepository<Car, String> {

}
----

=== Entity Classes

Entity classes are simple Java objects with fields or accessor methods designating each entity property.

You may use `jakarta.persistence.Entity` and the corresponding entity-related annotations of the Jakarta Persistence specification in the same package (such as `jakarta.persistence.Id` and `jakarta.persistence.Column`) to define and customize entities for relational databases.

You may use `jakarta.nosql.Entity` and the corresponding entity-related annotations of the Jakarta NoSQL specification in the same package (such as `jakarta.nosql.Id` and `jakarta.nosql.Column`) to define and customize entities for NoSQL databases.

Applications are recommended not to mix Entity annotations from different models for the sake of clarity and to allow for the Entity annotation to identify which provider is desired in cases where multiple types of Jakarta Data providers are available.

Repository implementations will search for the Entity annotation(s) they support and ignore other annotations.

=== Query Methods

In Jakarta Data, besides finding by an ID, custom queries can be written in two ways:

* `@Query` annotation: Defines a query string in the annotation.
* Query by method name: Defines a query based on naming convention used in the method name.

WARNING: Due to the variety of data sources, those resources might not work; it varies based on the Jakarta Data implementation and the database engine, which can provide queries on more than a Key or ID or not, such as a Key-value database.

==== Using the Query Annotation

The `@Query` annotation supports providing a search expression as a String. The specification does not define the query syntax, which may vary between vendors and data sources, such as SQL, JPQL, Cypher, CQL, etc.

[source,java]
----
@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {
  @Query("SELECT p FROM Products p WHERE p.name=?1")  // example in JPQL
  Optional<Product> findByName(String name);
}
----

Jakarta Data also includes the `@Param` annotation to define a binder annotation, where as with the query expression, each vendor will express the syntax freely such as `?`, `@`, etc..

[source,java]
----
@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {
  @Query("SELECT p FROM Products p WHERE p.name=:name")  // example in JPQL
  Optional<Product> findByName(@Param("name") String name);
}
----


==== Query by Method

The Query by method mechanism allows for creating query commands by naming convention.

[source,java]
----
@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {

  List<Product> findByName(String name);

  @OrderBy("price")
  List<Product> findByNameLike(String namePattern);

  @OrderBy(value = "price", descending = true)
  List<Product> findByNameLikeAndPriceLessThan(String namePattern, float priceBelow);

}
----

The parsing of query method names follows a specific format:

- The method name consists of the subject, the predicate, and optionally the order clause.
- The subject, defines the action (such as `find` or `delete`) , optionally followed by an expression (for example, `First10`), followed by `By`
- The predicate defines the query's condition or filtering criteria, where multiple conditions are delimited by `And` or `Or`. For example, `PriceLessThanAndNameLike`.
- The order clause, which is optional, begins with `OrderBy` and consists of an ordered collection of entity attributes by which to sort results, delimited by `Asc` or `Desc` to specify the sort direction of the preceding attribute.
- The method name is formed by combining the subject, predicate, and order clause, in that order.

Queries can also handle entities with related classes by specifying the relationship using dot notation.

Example query methods:

- `findByName(String name)`: Find entities by the 'name' property.
- `findByAgeGreaterThan(int age)`: Find entities where 'age' is greater than the specified value.
- `findByAuthorName(String authorName)`: Find entities by the 'authorName' property of a related entity.
- `findByCategoryNameAndPriceLessThan(String categoryName, double price)`: Find entities by 'categoryName' and 'price' properties, applying an 'And' condition.

==== BNF Grammar for Query Methods

Query methods allow developers to create database queries using method naming conventions. These methods consist of a subject, predicate, and optional order clause. This BNF notation provides a structured representation for understanding and implementing these powerful querying techniques in your applications.

[source,bnf]
----
<query-method> ::= <subject> <predicate> [<order-clause>]
<subject> ::= <action> "By" | <action> <expression> "By"
<action> ::= "find" | "delete" | "update" | "count" | "exists"
<expression> ::= <identifier> | <identifier> <number>
<predicate> ::= <condition> { ("And" | "Or") <condition> }
<condition> ::= <property> ["IgnoreCase"] ["Not"] [<operator>]
<operator> ::= "Equals" | "Is" | "LessThan"| "LessThanEqual" | "GreaterThan" | "GreaterThanEqual" | "Between" | "Empty" | "Like" | "IgnoreCase" | "In" | "Null" | "True" | "False"
<property> ::= <identifier> | <identifier> "_" <property>
<identifier> ::= <word>
<number> ::= <integer> | <float>
<integer> ::= <digit> { <digit> }
<float> ::= <integer> "." <integer>
<order-clause> ::= "OrderBy" { <order-item> } ( <order-item> | <property> )
<order-item> ::= <property> ("Asc" | "Desc")
----

Explanation of the BNF elements:

- `<query-method>`: Represents a query method, which consists of a subject, a predicate, and an optional order clause.
- `<subject>`: Defines the action (e.g., "find" or "delete") followed by an optional expression and "By."
- `<action>`: Specifies the action, such as "find" or "delete."
- `<expression>`: Represents an optional expression, such as "First10."
- `<predicate>`: Represents the query's condition or filtering criteria, which can include multiple conditions separated by "And" or "Or."
- `<condition>`: Specifies a property and an operator for the condition.
- `<operator>`: Defines the operator for the condition, like "Equals" or "LessThan."
- `<property>`: Represents a property name, which can include underscores for nested properties.
- `<identifier>`: Represents a word (e.g., property names, action names, etc.).
- `<number>`: Represents an integer or float number.
- `<integer>`: Represents a sequence of digits.
- `<float>`: Represents a floating-point number.
- `<order-clause>`: Specifies the optional order clause, starting with "OrderBy" and followed by one or more order items.
- `<order-item>`: Represents an ordered collection of entity attributes by which to sort results, including an optional "Asc" or "Desc" to specify the sort direction.

==== Entity Property Names

Within an entity, property names must be unique ignoring case. For simple entity properties, the field or accessor method name serves as the entity property name. In the case of embedded classes, entity property names are computed by concatenating the field or accessor method names at each level.

Assume an Order entity has an Address with a ZipCode. In that case, the access is `order.address.zipCode`. This form is used within annotations, such as `@Query`.

[source,java]
----
@Repository
public interface OrderRepository extends CrudRepository<Order, Long> {

  @Query("SELECT order FROM Order order WHERE order.address.zipCode=?1")
  List<Order> withZipCode(ZipCode zipCode);

}
----

The resolution algorithm for identifying properties in query methods by method name, with manual traversal points, is defined as follows:

1. *Method Name Parsing*:: The query method's name is parsed to identify the property or properties being referenced. Method names in query methods typically follow a pattern of "findBy[Property]", where "[Property]" represents the name of the property you want to query by.

2. *Property Extraction*:: The property name is extracted from the method name by removing the "findBy" prefix. For example, in the query method `findByAddressZipCode`, the property name extracted is `AddressZipCode`.

3. *Property Name Capitalization*:: The extracted property name is treated as is, with its original capitalization. For example, if the property name is `AddressZipCode`, it remains in camel case.

4. *Manual Traversal Points*:: To resolve ambiguity or to specify traversal through nested properties, underscores (`_`) can be used within the method name. Each underscore represents a traversal point to access nested properties. For example, `findByAddress_ZipCode` explicitly indicates traversal to the `Address` object's `ZipCode` property.

5. **Domain Class Property Lookup**: The framework checks the domain class associated with the repository for a property with the same name as the extracted property name (uncapitalized) in a case-insensitive manner. If the domain class has a property named `addressZipCode` or `addresszipcode`, this is considered a successful resolution.

6. *Nested Property Handling*:: If the extracted property name includes underscores (`_`) indicating nested traversal, the framework follows the specified path to resolve the property.

7. *Resolution Outcome*:: If the framework successfully identifies a property in the domain class or along the specified traversal path that matches the extracted property name, it uses that property in the query to filter data.

Users are encouraged to follow Java's naming standards in formalizing Jakarta Data queries using name conventions, avoiding underscores in field names. The resolution algorithm for property identification relies on "findBy[Property]" naming, allowing manual traversal with underscores. Adhering to the camel case for property names ensures consistency and seamless query method naming in Jakarta Data, enabling effective data filtering and retrieval from domain classes.


*Scenario 1: Person Repository with findByAddressZipCode(ZipCode zipCode)*

In this scenario, we have the following data models:

[source,java]
----
class Person {
  private Long id;
  private Address address;
}

class Address {
  private Zipcode zipcode;
}
----

- The query method `findByAddressZipCode` takes a `ZipCode` object as a parameter.
- The Property Resolution Algorithm will parse the method name and extract `AddressZipCode`.
- It will then attempt to resolve the property named `addressZipCode` in the `Person` class, following automatic class splitting by camel case.
- Since the `Person` class has an `Address` property, it will recursively follow the path to the `Address` class.
- In the `Address` class, it will identify the `zipcode` property and filter `Person` records based on the provided `Zipcode` object within the `Address` object.

*Scenario 2: People Repository with findByAddressZipCode(String addressZipCode)*


In this scenario, we have the following data model:

[source,java]
----
class Person {
  private Long id;
  private String addressZipCode;
}
----

- The query method `findByAddressZipCode` takes a `String` parameter named `addressZipCode`.
- The Property Resolution Algorithm will parse the method name and extract `AddressZipCode`.
- It will then attempt to resolve the property named `addressZipCode` in the `Person` class, following automatic class splitting by camel case.
- If a property named `addressZipCode` of type `String` exists in the `Person` class or its nested objects, the query will filter `Person` records based on the provided `addressZipCode` string.

*Scenario 3: OrderRepository` Repository with `findByAddress_ZipCode(ZipCode zipCode)*

In this scenario, we have the following data models:

[source,java]
----
class Order {
  private Long id;
  private String addressZipCode;
  private Address address;
}

class Address {
  private Zipcode zipcode;
}
----

- The query method `findByAddress_ZipCode` takes a `Zipcode` object as a parameter.
- The method name includes an underscore (`_`) indicating manual traversal points.
- The Property Resolution Algorithm will parse the method name and extract `Address_ZipCode`, recognizing the underscore as a traversal point.
- It will then attempt to resolve the property named `Address` within the `Order` class, followed by the `zipcode` property within the `Address` class, following manual traversal points.
- If properties `Address` and `ZipCode` are found in the appropriate classes or their nested objects, the query will filter `Order` records based on the provided `Zipcode` object within the `Address` object.


*Scenario 4: People Repository with findByAddressZipCode(String addressZipCode)*


In this scenario, we have the following data model:

[source,java]
----
class Person {
  private Long id;
  private String addressZipcode;
}
----

- The query method `findByAddressZipCode` takes a `String` parameter named `addressZipCode`.
- The Property Resolution Algorithm will parse the method name and extract `AddressZipCode`.
- It will then attempt to resolve the property named `addressZipcode` in the `Person` class, following automatic class splitting by case-insensitive.
- If a property named `addressZipCode` of type `String` exists in the `Person` class or its nested objects, the query will filter `Person` records based on the provided `addressZipCode` string.


WARNING: Define as a priority following standard Java naming conventions, camel case,  using underscore as the last resort.

In queries by method name, `Id` is an alias for the entity property that is designated as the id. Entity property names that are used in queries by method name must not contain reserved words.

===== Query Methods Keywords

The following table lists the subject keywords generally supported by Jakarta Data.

|===
|Keyword |Description

|findBy
|General query method returning the repository type.

|deleteBy
|Delete query method returning either no result (void) or the delete count.

|countBy
|Count projection returning a numeric result.

|existsBy
|Exists projection, returning as a `boolean` result.
|===

Jakarta Data implementations support the following list of predicate keywords to the extent that the database is capable of the behavior. A repository method will raise `jakarta.data.exceptions.DataException` or a more specific subclass of the exception if the database does not provide the requested functionality.

|===
|Keyword |Description | Method signature Sample

|And
|The `and` operator.
|findByNameAndYear

|Or
|The `or` operator.
|findByNameOrYear

|Between
|Find results where the property is between the given values
|findByDateBetween

|Empty
|Find results where the property is an empty collection or has a null value.
|deleteByPendingTasksEmpty

|LessThan
|Find results where the property is less than the given value
|findByAgeLessThan

|GreaterThan
|Find results where the property is greater than the given value
|findByAgeGreaterThan

|LessThanEqual
|Find results where the property is less than or equal to the given value
|findByAgeLessThanEqual

|GreaterThanEqual
|Find results where the property is greater than or equal to the given value
|findByAgeGreaterThanEqual

|Like
|Finds string values "like" the given expression
|findByTitleLike

|IgnoreCase
|Requests that string values be compared independent of case for query conditions and ordering.
|findByStreetNameIgnoreCaseLike

|In
|Find results where the property is one of the values that are contained within the given list
|findByIdIn

|Null
|Finds results where the property has a null value.
|findByYearRetiredNull

|True
|Finds results where the property has a boolean value of true.
|findBySalariedTrue

|False
|Finds results where the property has a boolean value of false.
|findByCompletedFalse

|OrderBy
|Specify a static sorting order followed by the property path and direction of ascending.
|findByNameOrderByAge

|OrderBy____Desc
|Specify a static sorting order followed by the property path and direction of descending.
|findByNameOrderByAgeDesc

|OrderBy____Asc
|Specify a static sorting order followed by the property path and direction of ascending.
|findByNameOrderByAgeAsc

|OrderBy____(Asc\|Desc)*(Asc\|Desc)
|Specify several static sorting orders
|findByNameOrderByAgeAscNameDescYearAsc

|===

====== Logical Operator Precedence

For relational databases, the logical operator `And` takes precedence over `Or`, meaning that `And` is evaluated on conditions before `Or` when both are specified on the same method. For other database types, the precedence is limited to the capabilities of the database. For example, some graph databases are limited to precedence in traversal order.

=== Special Parameter Handling

Jakarta Data also supports particular parameters to define pagination and sorting.

Jakarta Data recognizes, when specified on a repository method after the query parameters, specific types, like `Limit`, `Pageable`, and `Sort`, to dynamically apply limits, pagination, and sorting to queries. The following example demonstrates these features:

[source,java]
----
@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {

  List<Product> findByName(String name, Pageable pageable);

  List<Product> findByNameLike(String pattern, Limit max, Sort... sorts);

}
----

You can define simple sorting expressions by using property names.

[source,java]
----
Sort name = Sort.asc("name");
----

You can combine sorting with a starting page and maximum page size by using property names.

[source,java]
----
Pageable pageable = Pageable.ofSize(20).page(1).sortBy(Sort.desc("price"));
first20 = products.findByNameLike(name, pageable);

----

=== Precedence of Sort Criteria

The specification defines different ways of providing sort criteria on queries. This section discusses how these different mechanisms relate to each other.

==== Sort Criteria within Query Language

Sort criteria can be hard-coded directly within query language by making use of the `@Query` annotation. A repository method that is annotated with `@Query` with a value that contains an `ORDER BY` clause (or query language equivalent) must not provide sort criteria via the other mechanisms.

A repository method that is annotated with `@Query` with a value that does not contain an `ORDER BY` clause and ends with a `WHERE` clause (or query language equivalents to these) can use other mechanisms that are defined by this specification for providing sort criteria.

==== Static Mechanisms for Sort Criteria

Sort criteria is provided statically for a repository method by using the `OrderBy` keyword or by annotating the method with one or more `@OrderBy` annotations. The `OrderBy` keyword cannot be intermixed with the `@OrderBy` annotation or the `@Query` annotation. Static sort criteria takes precedence over dynamic sort criteria in that static sort criteria is evaluated first. When static sort criteria sorts entities to the same position, dynamic sort criteria is applied to further order those entities.

==== Dynamic Mechanisms for Sort Criteria

Sort criteria is provided dynamically to repository methods either via `Sort` parameters or via a `Pageable` parameter that has one or more `Sort` values. `Sort` and `Pageable` containing `Sort` must not both be provided to the same method.

==== Examples of Sort Criteria Precedence

The following examples work through scenarios where static and dynamic sort criteria are provided to the same method.

[source,java]
----
// Sorts first by type. When type is the same, applies the Pageable's sort criteria
Page<User> findByNameStartsWithOrderByType(String namePrefix, Pageable pagination);

// Sorts first by type. When type is the same, applies the criteria in the Sorts
List<User> findByNameStartsWithOrderByType(String namePrefix, Sort... sorts);

// Sorts first by age. When age is the same, applies the Pageable's sort criteria
@OrderBy("age")
Page<User> findByNameStartsWith(String namePrefix, Pageable pagination);

// Sorts first by age. When age is the same, applies the criteria in the Sorts
@OrderBy("age")
List<User> findByNameStartsWith(String namePrefix, Sort... sorts);

// Sorts first by name. When name is the same, applies the Pageable's sort criteria
@Query("SELECT u FROM User u WHERE (u.age > ?1)")
@OrderBy("name")
KeysetAwarePage<User> olderThan(int age, Pageable pagination);
----

=== Keyset Pagination

Keyset pagination aims to reduce missed and duplicate results across pages by querying relative to the observed values of entity properties that constitute the sorting criteria. Keyset pagination can also offer an improvement in performance because it avoids fetching and ordering results from prior pages by causing those results to be non-matching. A Jakarta Data provider appends additional conditions to the query and tracks keyset values automatically when `KeysetAwareSlice` or `KeysetAwarePage` are used as the repository method return type. The application invokes `nextPageable` or `previousPageable` on the keyset aware slice or page to obtain a `Pageable` which keeps track of the keyset values.

For example,

[source,java]
----
@Repository
public interface CustomerRepository extends CrudRepository<Customer, Long> {
  KeysetAwareSlice<Customer> findByZipcodeOrderByLastNameAscFirstNameAscIdAsc(
                                 int zipcode, Pageable pageable);
}
----

You can obtain the next page with,

[source,java]
----
for (Pageable p = Pageable.ofSize(50); p != null; ) {
  page = customers.findByZipcodeOrderByLastNameAscFirstNameAscIdAsc(55901, p);
  ...
  p = page.nextPageable();
}
----

Or you can obtain the next (or previous) page relative to a known entity,

[source,java]
----
Customer c = ...
Pageable p = Pageable.ofSize(50).afterKeyset(c.lastName, c.firstName, c.id);
page = customers.findByZipcodeOrderByLastNameAscFirstNameAscIdAsc(55902, p);
----

The sort criteria for a repository method that performs keyset pagination must uniquely identify each entity and must be provided by:

* `OrderBy` name pattern of the repository method (as in the examples above) or `@OrderBy` annotation(s) on the repository method.
* `Sort` parameters of the `Pageable` that is supplied to the repository method.

==== Example of Appending to Queries for Keyset Pagination

Without keyset pagination, a Jakarta Data provider that is based on Jakarta Persistence might compose the following JPQL for the `findByZipcodeOrderByLastNameAscFirstNameAscIdAsc` repository method from the prior example:

[source,jpql]
----
SELECT o FROM Customer o WHERE (o.zipCode = ?1)
                         ORDER BY o.lastName ASC, o.firstName ASC, o.id ASC
----

When keyset pagination is used, the keyset values from the `Cursor` of the `Pageable` are available as query parameters, allowing the Jakarta Data provider to append additional query conditions. For example,

[source,jpql]
----
SELECT o FROM Customer o WHERE (o.zipCode = ?1)
                           AND (   (o.lastName > ?2)
                                OR (o.lastName = ?2 AND o.firstName > ?3)
                                OR (o.lastName = ?2 AND o.firstName = ?3 AND o.id > ?4)
                               )
                         ORDER BY o.lastName ASC, o.firstName ASC, o.id ASC
----

==== Avoiding Missed and Duplicate Results

Because searching for the next page of results is relative to a last known position, it is possible with keyset pagination to allow some types of updates to data while pages are being traversed without causing missed results or duplicates to appear. If you add entities to a prior position in the traversal of pages, the shift forward of numerical position of existing entities will not cause duplicates entities to appear in your continued traversal of subsequent pages because keyset pagination does not query based on a numerical position. If you remove entities from a prior position in the traversal of pages, the shift backward of numerical position of existing entities will not cause missed entities in your continued traversal of subsequent pages because keyset pagination does not query based on a numerical position.

Other types of updates to data, however, will cause duplicate or missed results. If you modify entity properties which are used as the sort criteria, keyset pagination cannot prevent the same entity from appearing again or never appearing due to the altered values. If you add an entity that you previously removed, whether with different values or the same values, keyset pagination cannot prevent the entity from being missed or possibly appearing a second time due to its changed values.

==== Restrictions on use of Keyset Pagination

* The repository method signature must return `KeysetAwareSlice` or `KeysetAwarePage`. A repository method with return type of `KeysetAwareSlice` or `KeysetAwarePage` must raise `UnsupportedOperationException` if the database is incapable of keyset pagination.
* The repository method signature must accept a `Pageable` parameter.
* Sort criteria must be provided and should be minimal.
* The combination of provided sort criteria must uniquely identify each entity.
* Page numbers for keyset pagination are estimated relative to prior page requests or the observed absence of further results and are not accurate. Page numbers must not be relied upon when using keyset pagination.
* Page totals and result totals are not accurate for keyset pagination and must not be relied upon.
* A next or previous page can end up being empty. You cannot obtain a next or previous `Pageable` from an empty page because there are no keyset values relative to which to query.
* A repository method that is annotated with `@Query` and performs keyset pagination must omit the `ORDER BY` clause from the provided query and instead must supply the sort criteria via `@OrderBy` annotations or `Sort` parameters of `Pageable`. The provided query must end with a `WHERE` clause to which additional conditions can be appended by the Jakarta Data provider. The Jakarta Data provider is not expected to parse query text that is provided by the application.

==== Keyset Pagination Example with Sorts

Here is an example where an application uses `@Query` to provide a partial query to which the Jakarta Data provider can generate and append additional query conditions and an `ORDER BY` clause.

[source,java]
----
@Repository
public interface CustomerRepository extends CrudRepository<Customer, Long> {
  @Query("SELECT o FROM Customer o WHERE (o.totalSpent / o.totalPurchases > ?1)")
  KeysetAwareSlice<Customer> withAveragePurchaseAbove(float minimum, Pageable pagination);
}
----

Example traversal of pages:

[source,java]
----
for (Pageable p = Pageable.ofSize(25).sortBy(Sort.desc("yearBorn"), Sort.asc("name"), Sort.asc("id")));
     p != null; ) {
  page = customers.withAveragePurchaseAbove(50.0f, p);
  ...
  p = page.nextPageable();
}
----

=== Jakarta Data Vendor Extension Features for Java Persistence

When designing and implementing Java persistence solutions, Jakarta Data offers a set of powerful extension features that simplify the development process and enhance the overall code design. These features include Default Methods and Interface Queries.

==== Default Methods

Jakarta Data's Default Methods feature introduces a novel way of enriching repository interfaces with additional functionality. Default methods allow the creation of methods with default implementations directly within the Interface. These methods can be seamlessly integrated into the repository without breaking existing implementations.

For example, consider the following `BookRepository` interface:

[source,java]
----
@Repository
public interface BookRepository extends PageableRepository<Book, String> {

    List<Book> findByCategory(String category);

    List<Book> findByYear(Year year);

    default List<Book> releasedThisYear(){
        return findByYear(Year.now());
    }

    default Book register(Book book, Event<Book> event) {
        event.fire(book);
        // some logic here
        return this.save(book);
    }
}
----

In this Interface, the `releasedThisYear` method is a default method that utilizes the `findByYear` method to retrieve books published in the current year. Additionally, the `register` method provides a default implementation for registering a book and an event.

Benefits for Java Developers:

- **Smooth Evolution of Interfaces:** Default Methods enable the seamless addition of new methods to existing repository interfaces. It ensures compatibility with existing implementations while incorporating new features.

- **Enhanced Interface Usability:** Developers can create default implementations for common operations within the Interface itself, enhancing the usability of the repository interface.

- **Standardized Behaviors:** Default methods enable the definition of standardized behaviors across different repository interfaces, simplifying code maintenance.

Combine with Interface Queries:
You can also combine Default Methods with Interface Queries to create comprehensive and reusable repository interfaces that include common queries and default implementations for common operations.

== Interface Queries

Interface queries are a powerful feature that allows the creation of common queries in separate interfaces, which can then be plugged into repository interfaces. It promotes code reuse and modularity, making it easier to manage and maintain query definitions.

For instance, consider the `PetQueries` interface that defines common queries for pet-related repositories:

[source,java]
----
public interface PetQueries<T extends Pet> {

    List<T> findByName(String name);

    List<T> findByBreed(String breed);
}
----

These queries can be integrated into repositories for different pet types, such as `DogRepository` and `CatRepository`:

[source,java]
----
@Repository
public interface DogRepository extends PageableRepository<Dog, String>,
        PetQueries<Dog> {
}

@Repository
public interface CatRepository extends PageableRepository<Cat, String>,
        PetQueries<Cat> {
}
----

This approach centralizes common query definitions, making them easily accessible across multiple repository interfaces.

Benefits for Java Developers:

- **Reusability and Modularity:** Interface Queries facilitate the creation of common query definitions in separate interfaces. These queries can be easily reused across different repository implementations, promoting code reusability.

- **Simplified Code Maintenance:** By centralizing query definitions, Java developers can efficiently manage and update queries across multiple repositories, reducing redundancy and minimizing errors.

Combine with Default Methods:
Combining Interface Queries and Default Methods creates repository interfaces with standardized queries and default implementations for common operations, enhancing code organization and usability.

In summary, Jakarta Data's extension features offer a range of benefits for Java developers. These features empower developers to evolve interfaces gracefully, streamline query management, and implement intricate functionality while maintaining code integrity and design principles.

These extension features enhance the capabilities of Jakarta Data repositories, promoting code reusability, modularity, and customization.