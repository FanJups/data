// Copyright (c) 2022 Contributors to the Eclipse Foundation
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

== Introduction

The Jakarta Data specification provides an API for easier data access. A
Java developer can split the persistence from the model with several features,
such as the ability to compose custom query methods on a Repository interface where the framework
will implement it.

There is no doubt about the importance of data around the application. We often talk about a stateless application, where we delegate the application's state to the database.

Dealing with a database is one of the biggest challenges within a software architecture. In addition to choosing one of several options on the market, it is necessary to consider the persistence integrations. Jakarta Data makes life easier for Java developers.

=== Goals

Jakarta Data is a pivotal solution that addresses a fundamental challenge in Java application development: the seamless integration of diverse data sources. This integration is crucial for applications with many databases and storage technologies.

The primary problem Jakarta Data sets out to solve is the complexity and inconsistency that arises when Java applications encounter various database systemsâ€”some relational, some NoSQL, and others unique. Managing these diverse data sources can be daunting, often requiring developers to write specialized code for each storage technology.

Jakarta Data takes this challenge further by enhancing the concept of a "persistence agnostic API" with a Domain-Driven Design (DDD) approach. This approach enables developers to work with different databases and storage engines and align their data access strategies with the core principles of DDD, where the domain model plays a central role in shaping the application's architecture.

Jakarta Data is guided by a set of clear and well-defined objectives to simplify data integration and enhance data access for Java developers. These objectives serve as the pillars of its design philosophy, ensuring that it addresses real-world challenges and provides concrete advantages to developers:

* *Jakarta Data is engineered to tackle a fundamental problem*: simplifying data access and manipulation within Java applications that interact with diverse databases and storage sources.
* *Jakarta Data is designed to be "persistence agnostic*." In this context, "agnostic" does not mean "portable" but implies that Jakarta Data is not tied to a specific database technology. It offers a flexible, adaptable framework that allows you to work with the databases and storage sources that best suit your project's needs. This agnostic approach ensures that Jakarta Data can cater to various use cases.
* *Enhancing Domain-Driven Design (DDD)*: Jakarta Data enhances the concept of a "persistence agnostic API" with a Domain-Driven Design (DDD) approach. It enables developers to align their data access strategies with the core principles of DDD, where the domain model plays a central role in shaping the application's architecture.
* *Unified API*: Jakarta Data provides a unified and standardized API for interacting with various data sources. This consistency simplifies development by allowing developers to use the same tools and practices regardless of the underlying database technology.
* *Pluggable and Extensible*: Jakarta Data is designed to be pluggable and extensible. Even in cases where the API doesn't directly support a specific behavior of a storage engine, Jakarta Data aims to provide an extensible API to enable developers to customize and adapt as needed.
* *Simplified and Domain-Centric Querying and Database Operations*: Jakarta Data strongly emphasizes simplifying and aligning querying and database operations with your application's domain model. By offering domain-centric query capabilities through annotations, a driver, or query-by-method, Jakarta Data strives to be compatible with multiple databases and inherently closer to your application's domain logic. This approach ensures that your queries and operations are more portable among various persistence engines, making working with different data sources easier while maintaining a cohesive and domain-focused codebase.
* *Seamless Integration*: Jakarta Data enables seamless integration between Java applications and various persistence layers, making it easier for developers to work with different databases and storage sources without extensive customization.

=== Non-Goals

As with any software component, these decisions come with trade-offs and the following non-goals:

* Provide specific features of Jakarta Persistence, Jakarta NoSQL, etc. Those APIs have their own specifications.
* Replace the Jakarta Persistence or Jakarta NoSQL specifications. Indeed, Jakarta Data will work as a complement to these specifications as an agnostic API.

=== Conventions

include::project_team.adoc[]
